import os
import sys
import logging
import json
import argparse
import time
from pathlib import Path
from concurrent.futures import ThreadPoolExecutor, as_completed
from tqdm import tqdm

# Importa m√≥dulos do sistema original
from transcription import TranscriptionEngine
from video_analysis import VideoAnalyzer
from search_engine import ContentSearchEngine
import config

# Novos m√≥dulos para extens√£o
from images import ImageAnalyzer
from db_mongo import MongoManager

# Configura√ß√£o de logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("orchestrator_extended.log"),
        logging.StreamHandler(sys.stdout)
    ]
)

logger = logging.getLogger(__name__)

class ExtendedOrchestrator:
    """
    Orquestrador estendido com suporte a:
    - Processamento de v√≠deos (original)
    - Processamento de imagens com IA
    - Persist√™ncia em MongoDB por diret√≥rio
    - Busca unificada em v√≠deos e imagens
    """
    
    def __init__(self, use_mongo=True):
        self.use_mongo = use_mongo
        
        # Componentes originais
        self.transcription_engine = TranscriptionEngine()
        self.video_analyzer = VideoAnalyzer()
        
        # Novo componente para imagens
        self.image_analyzer = ImageAnalyzer()
        
        # Database manager (MongoDB ou SQLite)
        if use_mongo:
            try:
                self.db_manager = MongoManager()
                logger.info("Usando MongoDB como banco de dados")
            except Exception as e:
                logger.warning(f"Erro ao conectar MongoDB: {e}. Fallback para SQLite.")
                from database import DatabaseManager
                self.db_manager = DatabaseManager()
                self.use_mongo = False
        else:
            from database import DatabaseManager
            self.db_manager = DatabaseManager()
            logger.info("Usando SQLite como banco de dados")
        
        # Search engine (adapta-se ao tipo de banco)
        if self.use_mongo:
            self.search_engine = MongoSearchEngine(self.db_manager)
        else:
            self.search_engine = ContentSearchEngine(self.db_manager)
        
        logger.info("Orquestrador estendido inicializado com sucesso")
    
    def process_video(self, video_path, progress_bar=None):
        """
        Processa um √∫nico v√≠deo (vers√£o adaptada para MongoDB)
        """
        try:
            video_name = os.path.basename(video_path)
            
            if progress_bar is None:
                progress_bar = tqdm(total=7, desc=f"Processando {video_name[:30]}...", 
                                  unit="etapa", leave=True)
            
            progress_bar.set_description(f"üìÅ Verificando: {video_name[:30]}...")
            
            # Verifica se o v√≠deo j√° foi processado
            if self.use_mongo:
                existing_record = self.db_manager.get_video_by_path(video_path)
            else:
                existing_record = self.db_manager.get_video_by_path(video_path)
            
            if existing_record:
                progress_bar.set_description(f"‚úÖ J√° processado: {video_name[:30]}")\n                progress_bar.update(7)\n                progress_bar.close()\n                return existing_record.get('_id') if self.use_mongo else existing_record.id\n            \n            progress_bar.update(1)\n            progress_bar.set_description(f"üìä Criando registro: {video_name[:30]}...")\n            \n            # Cria documento para o v√≠deo\n            video_doc = {\n                'file_path': video_path,\n                'file_name': os.path.basename(video_path),\n                'file_size': os.path.getsize(video_path),\n                'directory': str(Path(video_path).parent)\n            }\n            \n            # Obt√©m dura√ß√£o do v√≠deo\n            duration = self.transcription_engine.get_video_duration(video_path)\n            if duration:\n                video_doc['duration'] = duration\n            \n            progress_bar.update(1)\n            progress_bar.set_description(f"üé§ Transcrevendo: {video_name[:30]}...")\n            \n            # Transcri√ß√£o\n            transcription_results = self.transcription_engine.transcribe_video(\n                video_path, languages=['pt'], progress_callback=progress_bar\n            )\n            \n            if not transcription_results:\n                progress_bar.set_description(f"‚ùå Falha na transcri√ß√£o: {video_name[:30]}")\n                progress_bar.close()\n                return None\n            \n            video_doc['transcript'] = transcription_results\n            \n            progress_bar.update(1)\n            progress_bar.set_description(f"üëÅÔ∏è Analisando visual: {video_name[:30]}...")\n            \n            # An√°lise visual\n            frames = self.video_analyzer.extract_video_frames(video_path)\n            visual_analysis = self.video_analyzer.analyze_visual_content(frames)\n            video_doc['visual_analysis'] = visual_analysis\n            \n            progress_bar.update(1)\n            progress_bar.set_description(f"üè∑Ô∏è Classificando: {video_name[:30]}...")\n            \n            # Classifica√ß√£o\n            transcript_text = transcription_results.get('pt', {}).get('text', '')\n            if transcript_text:\n                classification = self.video_analyzer.classify_content(\n                    transcript_text, \n                    visual_analysis\n                )\n                video_doc['classification'] = classification\n                \n                # Extra√ß√£o de keywords\n                keywords = self.video_analyzer.extract_keywords(transcript_text)\n                video_doc['keywords'] = keywords\n                \n                # Gera√ß√£o de contexto\n                video_doc['video_context'] = self.video_analyzer.generate_video_context(\n                    transcript_text,\n                    visual_analysis,\n                    classification\n                )\n            \n            progress_bar.update(1)\n            progress_bar.set_description(f"üíæ Salvando no banco: {video_name[:30]}...")\n            \n            # Salva no banco de dados\n            if self.use_mongo:\n                video_id = self.db_manager.upsert_video(video_doc)\n            else:\n                # Converte para SQLAlchemy model se necess√°rio\n                from database import VideoRecord\n                video_record = VideoRecord(\n                    file_path=video_doc['file_path'],\n                    file_name=video_doc['file_name'],\n                    file_size=video_doc['file_size'],\n                    duration=video_doc.get('duration'),\n                    transcript_pt=transcript_text,\n                    category=video_doc.get('classification', {}).get('category'),\n                    confidence_score=video_doc.get('classification', {}).get('confidence'),\n                    keywords=json.dumps(video_doc.get('keywords', [])),\n                    video_context=video_doc.get('video_context')\n                )\n                video_id = self.db_manager.add_video(video_record)\n            \n            progress_bar.update(1)\n            progress_bar.set_description(f"‚úÖ Conclu√≠do: {video_name[:30]}")\n            progress_bar.close()\n            \n            return video_id\n            \n        except Exception as e:\n            if progress_bar:\n                progress_bar.set_description(f"‚ùå Erro: {video_name[:30]} - {str(e)[:50]}")\n                progress_bar.close()\n            logger.error(f"Erro ao processar v√≠deo {video_path}: {str(e)}")\n            return None
    
    def process_image(self, image_path, progress_bar=None):\n        \"\"\"\n        Processa uma √∫nica imagem: an√°lise visual, gera√ß√£o de legenda e categoriza√ß√£o\n        \"\"\"\n        try:\n            image_name = os.path.basename(image_path)\n            \n            if progress_bar is None:\n                progress_bar = tqdm(total=4, desc=f"Processando {image_name[:30]}...", \n                                  unit="etapa", leave=True)\n            \n            progress_bar.set_description(f"üìÅ Verificando: {image_name[:30]}...")\n            \n            # Verifica se a imagem j√° foi processada\n            if self.use_mongo:\n                existing_record = self.db_manager.get_image_by_path(image_path)\n                if existing_record:\n                    progress_bar.set_description(f"‚úÖ J√° processado: {image_name[:30]}")\n                    progress_bar.update(4)\n                    progress_bar.close()\n                    return existing_record.get('_id')\n            \n            progress_bar.update(1)\n            progress_bar.set_description(f"üñºÔ∏è Analisando imagem: {image_name[:30]}...")\n            \n            # An√°lise completa da imagem\n            image_analysis = self.image_analyzer.describe_image(image_path)\n            if not image_analysis:\n                progress_bar.set_description(f"‚ùå Falha na an√°lise: {image_name[:30]}")\n                progress_bar.close()\n                return None\n            \n            progress_bar.update(1)\n            progress_bar.set_description(f"üè∑Ô∏è Categorizando: {image_name[:30]}...")\n            \n            # Categoriza√ß√£o\n            categorization = self.image_analyzer.categorize_image(\n                image_analysis['caption'],\n                image_analysis['visual_features'],\n                image_analysis['classification']\n            )\n            \n            # Monta documento para persist√™ncia\n            image_doc = {\n                'file_path': image_path,\n                'file_name': os.path.basename(image_path),\n                'file_size': os.path.getsize(image_path),\n                'directory': str(Path(image_path).parent),\n                'caption': image_analysis['caption'],\n                'keywords': image_analysis['keywords'],\n                'visual_features': image_analysis['visual_features'],\n                'classification': {\n                    **image_analysis['classification'],\n                    **categorization\n                }\n            }\n            \n            progress_bar.update(1)\n            progress_bar.set_description(f"üíæ Salvando no banco: {image_name[:30]}...")\n            \n            # Salva no banco\n            if self.use_mongo:\n                image_id = self.db_manager.upsert_image(image_doc)\n            else:\n                # SQLite n√£o tem suporte nativo a imagens no esquema atual\n                logger.warning("Processamento de imagens requer MongoDB")\n                image_id = None\n            \n            progress_bar.update(1)\n            progress_bar.set_description(f"‚úÖ Conclu√≠do: {image_name[:30]}")\n            progress_bar.close()\n            \n            return image_id\n            \n        except Exception as e:\n            if progress_bar:\n                progress_bar.set_description(f"‚ùå Erro: {image_name[:30]} - {str(e)[:50]}")\n                progress_bar.close()\n            logger.error(f"Erro ao processar imagem {image_path}: {str(e)}")\n            return None
    \n    def process_directory(self, directory_path, recursive=True, include_images=True):\n        \"\"\"\n        Processa todos os v√≠deos e imagens em um diret√≥rio\n        \"\"\"\n        try:\n            print(f"üìÅ Escaneando diret√≥rio: {directory_path}")\n            \n            directory = Path(directory_path)\n            \n            # Busca por arquivos de v√≠deo\n            video_paths = []\n            if recursive:\n                for ext in config.VIDEO_EXTENSIONS:\n                    video_paths.extend(list(directory.glob(f"**/*{ext}")))\n            else:\n                for ext in config.VIDEO_EXTENSIONS:\n                    video_paths.extend(list(directory.glob(f"*{ext}")))\n            \n            # Busca por arquivos de imagem (se habilitado)\n            image_paths = []\n            if include_images and self.use_mongo:\n                image_extensions = ['.jpg', '.jpeg', '.png', '.bmp', '.webp', '.tiff', '.gif']\n                if recursive:\n                    for ext in image_extensions:\n                        image_paths.extend(list(directory.glob(f"**/*{ext}")))\n                else:\n                    for ext in image_extensions:\n                        image_paths.extend(list(directory.glob(f"*{ext}")))\n            \n            total_files = len(video_paths) + len(image_paths)\n            \n            if total_files == 0:\n                print(f"‚ö†Ô∏è  Nenhum arquivo encontrado em: {directory_path}")\n                return []\n            \n            print(f"üé¨ Encontrados {len(video_paths)} v√≠deos e {len(image_paths)} imagens para processamento\\n")\n            \n            # Barra de progresso geral\n            overall_progress = tqdm(\n                total=total_files,\n                desc="üì∫ Processamento Geral",\n                unit="arquivo",\n                position=0,\n                leave=True\n            )\n            \n            results = {'videos': [], 'images': []}\n            \n            # Processa v√≠deos\n            for i, video_path in enumerate(video_paths):\n                try:\n                    overall_progress.set_description(f"üì∫ [{i+1}/{len(video_paths)}] Processando v√≠deos")\n                    video_id = self.process_video(str(video_path))\n                    if video_id:\n                        results['videos'].append(video_id)\n                    overall_progress.update(1)\n                except Exception as e:\n                    logger.error(f"Erro ao processar v√≠deo {video_path}: {str(e)}")\n                    overall_progress.update(1)\n            \n            # Processa imagens\n            for i, image_path in enumerate(image_paths):\n                try:\n                    overall_progress.set_description(f"üñºÔ∏è [{i+1}/{len(image_paths)}] Processando imagens")\n                    image_id = self.process_image(str(image_path))\n                    if image_id:\n                        results['images'].append(image_id)\n                    overall_progress.update(1)\n                except Exception as e:\n                    logger.error(f"Erro ao processar imagem {image_path}: {str(e)}")\n                    overall_progress.update(1)\n            \n            overall_progress.set_description(\n                f"‚úÖ Processamento conclu√≠do: {len(results['videos'])} v√≠deos, {len(results['images'])} imagens"\n            )\n            overall_progress.close()\n            \n            print(f"\\nüéâ Processamento conclu√≠do! {len(results['videos'])} v√≠deos e {len(results['images'])} imagens processados.")\n            return results\n            \n        except Exception as e:\n            logger.error(f"Erro ao processar diret√≥rio {directory_path}: {str(e)}")\n            return {'videos': [], 'images': []}\n    \n    def search_content(self, query, content_type="all", limit=10):\n        \"\"\"\n        Busca unificada em v√≠deos e/ou imagens\n        \"\"\"\n        results = {'videos': [], 'images': []}\n        \n        if content_type in ["all", "videos"]:\n            if self.use_mongo:\n                video_results = self.db_manager.search_videos_text(query, limit)\n                results['videos'] = video_results\n            else:\n                video_results = self.search_engine.search_by_text(query, limit)\n                results['videos'] = [r['video'] for r in video_results]\n        \n        if content_type in ["all", "images"] and self.use_mongo:\n            image_results = self.db_manager.search_images_text(query, limit)\n            results['images'] = image_results\n        \n        return results\n    \n    def get_directory_summary(self, directory):\n        \"\"\"\n        Retorna resumo de um diret√≥rio espec√≠fico\n        \"\"\"\n        if self.use_mongo:\n            return self.db_manager.get_directory_summary(directory)\n        else:\n            # Implementa√ß√£o simples para SQLite\n            videos = [v for v in self.db_manager.get_all_videos() \n                     if str(Path(v.file_path).parent) == directory]\n            \n            summary = {\n                'directory': directory,\n                'videos': {\n                    'count': len(videos),\n                    'total_duration': sum(v.duration or 0 for v in videos),\n                    'categories': {}\n                },\n                'images': {'count': 0, 'categories': {}}  # SQLite n√£o suporta imagens\n            }\n            \n            for video in videos:\n                category = video.category or 'outros'\n                summary['videos']['categories'][category] = summary['videos']['categories'].get(category, 0) + 1\n            \n            return summary
    \n    def search_by_directory(self, directory, content_type="all"):\n        \"\"\"\n        Busca todo conte√∫do de um diret√≥rio espec√≠fico\n        \"\"\"\n        results = {'videos': [], 'images': []}\n        \n        if content_type in ["all", "videos"]:\n            if self.use_mongo:\n                results['videos'] = self.db_manager.get_videos_by_directory(directory)\n            else:\n                all_videos = self.db_manager.get_all_videos()\n                results['videos'] = [v for v in all_videos \n                                   if str(Path(v.file_path).parent) == directory]\n        \n        if content_type in ["all", "images"] and self.use_mongo:\n            results['images'] = self.db_manager.get_images_by_directory(directory)\n        \n        return results\n\nclass MongoSearchEngine:\n    \"\"\"\n    Motor de busca adaptado para MongoDB\n    \"\"\"\n    \n    def __init__(self, mongo_manager):\n        self.db = mongo_manager\n        self.logger = logging.getLogger(__name__)\n    \n    def search_by_text(self, query, limit=10):\n        \"\"\"\n        Busca textual usando √≠ndices do MongoDB\n        \"\"\"\n        try:\n            results = self.db.search_videos_text(query, limit)\n            return [{'video': r, 'similarity_score': r.get('score', 0)} for r in results]\n        except Exception as e:\n            self.logger.error(f"Erro na busca textual: {e}")\n            return []\n    \n    def search_by_category(self, category):\n        \"\"\"\n        Busca por categoria\n        \"\"\"\n        try:\n            videos = self.db.get_videos_by_category(category)\n            return [{'video': v, 'confidence': v.get('classification', {}).get('confidence', 0)} \n                   for v in videos]\n        except Exception as e:\n            self.logger.error(f"Erro na busca por categoria: {e}")\n            return []\n    \n    def get_content_summary(self):\n        \"\"\"\n        Resumo global do conte√∫do\n        \"\"\"\n        try:\n            return self.db.get_global_summary()\n        except Exception as e:\n            self.logger.error(f"Erro ao gerar resumo: {e}")\n            return {}\n\ndef main():\n    # Configura√ß√£o dos argumentos de linha de comando\n    parser = argparse.ArgumentParser(description='Orquestrador estendido com suporte a imagens e MongoDB')\n    \n    # Op√ß√£o global para banco\n    parser.add_argument('--use-sqlite', action='store_true', \n                       help='Usar SQLite em vez de MongoDB')\n    \n    # Subcomandos\n    subparsers = parser.add_subparsers(dest='command', help='Comando a ser executado')\n    \n    # Comando para processar diret√≥rio\n    process_parser = subparsers.add_parser('process', help='Processar v√≠deos e imagens')\n    process_parser.add_argument('directory', help='Diret√≥rio contendo arquivos para processamento')\n    process_parser.add_argument('--recursive', '-r', action='store_true', \n                               help='Buscar arquivos recursivamente em subdiret√≥rios')\n    process_parser.add_argument('--videos-only', action='store_true', \n                               help='Processar apenas v√≠deos')\n    \n    # Comando para buscar conte√∫do\n    search_parser = subparsers.add_parser('search', help='Buscar v√≠deos e imagens')\n    search_parser.add_argument('--query', '-q', help='Termo de busca textual')\n    search_parser.add_argument('--category', '-c', help='Buscar por categoria')\n    search_parser.add_argument('--keywords', '-k', help='Buscar por palavras-chave (separadas por v√≠rgula)')\n    search_parser.add_argument('--directory', '-d', help='Buscar em diret√≥rio espec√≠fico')\n    search_parser.add_argument('--type', choices=['all', 'videos', 'images'], default='all',\n                              help='Tipo de conte√∫do a buscar')\n    \n    # Comando para resumo\n    summary_parser = subparsers.add_parser('summary', help='Mostrar resumo do conte√∫do')\n    summary_parser.add_argument('--directory', '-d', help='Resumo de diret√≥rio espec√≠fico')\n    \n    # Parseia os argumentos\n    args = parser.parse_args()\n    \n    # Inicializa o orquestrador\n    use_mongo = not args.use_sqlite\n    orchestrator = ExtendedOrchestrator(use_mongo=use_mongo)\n    \n    # Executa o comando especificado\n    if args.command == 'process':\n        start_time = time.time()\n        include_images = not args.videos_only\n        results = orchestrator.process_directory(args.directory, args.recursive, include_images)\n        elapsed_time = time.time() - start_time\n        logger.info(f"Processamento conclu√≠do em {elapsed_time:.2f} segundos")\n        \n    elif args.command == 'search':\n        if args.directory:\n            results = orchestrator.search_by_directory(args.directory, args.type)\n            print(f"\\nConte√∫do do diret√≥rio '{args.directory}':")\n            \n            if results['videos']:\n                print(f"\\nüì∫ V√≠deos ({len(results['videos'])}):")\n                for i, video in enumerate(results['videos'], 1):\n                    file_name = video.get('file_name') if use_mongo else video.file_name\n                    category = video.get('classification', {}).get('category', 'outros') if use_mongo else video.category\n                    print(f"  {i}. {file_name} (Categoria: {category})")\n            \n            if results['images']:\n                print(f"\\nüñºÔ∏è Imagens ({len(results['images'])}):")\n                for i, image in enumerate(results['images'], 1):\n                    file_name = image.get('file_name')\n                    category = image.get('classification', {}).get('category', 'outros')\n                    caption = image.get('caption', '')[:100] + ('...' if len(image.get('caption', '')) > 100 else '')\n                    print(f"  {i}. {file_name} (Categoria: {category})")\n                    if caption:\n                        print(f"     Descri√ß√£o: {caption}")\n        \n        elif args.query:\n            results = orchestrator.search_content(args.query, args.type)\n            print(f"\\nResultados da busca por '{args.query}':")\n            \n            if results['videos']:\n                print(f"\\nüì∫ V√≠deos encontrados:")\n                for i, video in enumerate(results['videos'], 1):\n                    if use_mongo:\n                        file_name = video.get('file_name')\n                        context = video.get('video_context', '')[:150]\n                        score = video.get('score', 0)\n                    else:\n                        file_name = video.file_name\n                        context = video.video_context[:150] if video.video_context else ''\n                        score = 0\n                    \n                    print(f"\\n{i}. {file_name}")\n                    print(f"   Score: {score:.4f}")\n                    print(f"   Contexto: {context}...")\n            \n            if results['images']:\n                print(f"\\nüñºÔ∏è Imagens encontradas:")\n                for i, image in enumerate(results['images'], 1):\n                    file_name = image.get('file_name')\n                    caption = image.get('caption', '')[:150]\n                    score = image.get('score', 0)\n                    \n                    print(f"\\n{i}. {file_name}")\n                    print(f"   Score: {score:.4f}")\n                    print(f"   Descri√ß√£o: {caption}...")\n        \n        else:\n            print("Erro: Especifique um crit√©rio de busca (--query, --category, --keywords ou --directory)")\n    \n    elif args.command == 'summary':\n        if args.directory:\n            summary = orchestrator.get_directory_summary(args.directory)\n            print(f"\\n=== RESUMO DO DIRET√ìRIO: {args.directory} ===")\n            \n            videos = summary.get('videos', {})\n            images = summary.get('images', {})\n            \n            print(f"üì∫ V√≠deos: {videos.get('count', 0)}")\n            if videos.get('total_duration'):\n                print(f"   Dura√ß√£o total: {videos['total_duration']/3600:.1f} horas")\n            \n            print(f"üñºÔ∏è Imagens: {images.get('count', 0)}")\n            \n            print("\\nCategorias de v√≠deos:")\n            for category, count in videos.get('categories', {}).items():\n                print(f"  - {category}: {count}")\n            \n            print("\\nCategorias de imagens:")\n            for category, count in images.get('categories', {}).items():\n                print(f"  - {category}: {count}")\n        \n        else:\n            if use_mongo:\n                summary = orchestrator.db_manager.get_global_summary()\n            else:\n                # Fallback para search engine original\n                summary = orchestrator.search_engine.get_content_summary()\n            \n            print("\\n=== RESUMO GLOBAL DO CONTE√öDO ===")\n            \n            if use_mongo:\n                videos = summary.get('videos', {})\n                images = summary.get('images', {})\n                \n                print(f"üì∫ Total de v√≠deos: {videos.get('total_count', 0)}")\n                print(f"   Dura√ß√£o total: {videos.get('total_duration_hours', 0):.1f} horas")\n                print(f"   Diret√≥rios: {len(videos.get('directories', []))}")\n                \n                print(f"üñºÔ∏è Total de imagens: {images.get('total_count', 0)}")\n                print(f"   Diret√≥rios: {len(images.get('directories', []))}")\n                \n                print("\\nCategorias de v√≠deos:")\n                for category, count in videos.get('categories', {}).items():\n                    print(f"  - {category}: {count}")\n                \n                print("\\nCategorias de imagens:")\n                for category, count in images.get('categories', {}).items():\n                    print(f"  - {category}: {count}")\n            else:\n                # Formato original do SQLite\n                print(f"Total de v√≠deos: {summary.get('total_videos', 0)}")\n                print(f"Dura√ß√£o total: {summary.get('total_duration_hours', 0):.1f} horas")\n                \n                print("\\nV√≠deos por categoria:")\n                for category, count in summary.get('categories', {}).items():\n                    print(f"  - {category}: {count} v√≠deos")\n    \n    else:\n        parser.print_help()\n\nif __name__ == "__main__":\n    main()\n"}}
</function_results>

Agora vou atualizar o arquivo de configura√ß√£o para incluir as novas op√ß√µes:

<function_calls>
<invoke name="edit_files">
<parameter name="title">Adiciona configura√ß√µes para MongoDB e processamento de imagens
